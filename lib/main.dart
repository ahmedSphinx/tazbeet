import 'package:tazbeet/services/app_logging.dart';
import 'package:tazbeet/services/navigation_service.dart';

import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:provider/provider.dart';
import 'package:tazbeet/blocs/auth/auth_bloc.dart';
import 'package:tazbeet/blocs/auth/auth_event.dart';
import 'package:tazbeet/blocs/auth/auth_state.dart';
import 'package:tazbeet/blocs/mood/mood_bloc.dart';
import 'package:tazbeet/blocs/task_details/task_details_bloc.dart';
import 'package:tazbeet/blocs/user/user_bloc.dart';
import 'package:tazbeet/l10n/app_localizations.dart';
import 'package:tazbeet/services/auth_service.dart';
import 'package:tazbeet/services/color_customization_service.dart';
import 'package:tazbeet/services/task_sound_service.dart';
import 'package:tazbeet/services/ambient_service.dart';
import 'package:tazbeet/services/update_service.dart';
import 'package:tazbeet/services/firebase_service_wrapper.dart';
import 'models/mood.dart';
import 'models/user.dart';
import 'blocs/task_list/task_list_bloc.dart';
import 'blocs/category/category_bloc.dart';
import 'repositories/task_repository.dart';
import 'repositories/category_repository.dart';
import 'repositories/mood_repository.dart';
import 'repositories/user_repository.dart';
import 'services/notification_service.dart';
import 'services/background_service.dart';
import 'services/emergency_service.dart';
import 'services/settings_service.dart' as settings;
import 'services/localization_service.dart';

import 'ui/screens/splash_screen.dart';
import 'ui/screens/mood_input_screen.dart';
import 'ui/themes/app_themes.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize Firebase with error handling
  final firebaseAvailable = await FirebaseServiceWrapper.initializeFirebase();
  if (!firebaseAvailable) {
    AppLogging.logWarning('Firebase not available - app will work in offline mode');
  }

  // Initialize Hive
  await Hive.initFlutter();

  // Register Hive adapters
  Hive.registerAdapter(MoodLevelAdapter());
  Hive.registerAdapter(MoodAdapter());
  Hive.registerAdapter(UserAdapter());

  // Initialize notification service
  final notificationService = NotificationService();
  await notificationService.initialize();

  // Initialize background service
  final backgroundService = BackgroundService();
  await backgroundService.initialize();

  // Initialize settings service
  final settingsService = settings.SettingsService();
  await settingsService.initialize();

  // Schedule mood check-in notifications if enabled
  if (settingsService.settings.enableMoodNotifications) {
    await notificationService.scheduleMoodCheckInNotifications(settingsService.settings.moodCheckInTimes);
  }

  // Initialize auth service
  final authService = AuthService();

  // Initialize task sound service
  final taskSoundService = TaskSoundService();
  await taskSoundService.initialize();

  // Initialize update service
  final updateService = UpdateService();

  // Perform automatic update check
  await updateService.checkForUpdatesAutomatically();

  // Initialize repositories
  final taskRepository = TaskRepository();
  final categoryRepository = CategoryRepository();
  final moodRepository = MoodRepository();
  final userRepository = UserRepository();
  final colorCustomizationService = ColorCustomizationService();

  await taskRepository.init();
  await categoryRepository.init();
  await moodRepository.init();
  await colorCustomizationService.initialize();

  // Create default categories if they don't exist  await categoryRepository.createDefaultCategories();

  runApp(
    Tazbeet(
      taskRepository: taskRepository,
      categoryRepository: categoryRepository,
      notificationService: notificationService,
      settingsService: settingsService,
      moodRepository: moodRepository,
      userRepository: userRepository,
      colorCustomizationService: colorCustomizationService,
      authService: authService,
      taskSoundService: taskSoundService,
      updateService: updateService,
    ),
  );
}

class Tazbeet extends StatelessWidget {
  final TaskRepository taskRepository;
  final CategoryRepository categoryRepository;
  final NotificationService notificationService;
  final settings.SettingsService settingsService;
  final MoodRepository moodRepository;
  final UserRepository userRepository;
  final ColorCustomizationService colorCustomizationService;
  final AuthService authService;
  final TaskSoundService taskSoundService;
  final UpdateService updateService;

  const Tazbeet({
    super.key,
    required this.taskRepository,
    required this.categoryRepository,
    required this.notificationService,
    required this.settingsService,
    required this.moodRepository,
    required this.userRepository,
    required this.colorCustomizationService,
    required this.authService,
    required this.taskSoundService,
    required this.updateService,
  });

  ThemeMode _getThemeMode(settings.ThemeMode customThemeMode) {
    switch (customThemeMode) {
      case settings.ThemeMode.light:
        return ThemeMode.light;
      case settings.ThemeMode.dark:
        return ThemeMode.dark;
      case settings.ThemeMode.system:
        return ThemeMode.system;
    }
  }

  Locale _getLocale(String languageCode) {
    return AppLocalizations.supportedLocales.contains(Locale(languageCode)) ? Locale(languageCode) : const Locale('en');
  }

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        Provider<TaskRepository>.value(value: taskRepository),
        Provider<CategoryRepository>.value(value: categoryRepository),
        Provider<MoodRepository>.value(value: moodRepository),
        Provider<UserRepository>.value(value: userRepository),
      ],
      child: MultiBlocProvider(
        providers: [
          BlocProvider<AuthBloc>(create: (context) => AuthBloc(authService)..add(AuthStarted())),
          BlocProvider<TaskListBloc>(
            create: (context) => TaskListBloc(taskRepository: context.read<TaskRepository>(), categoryRepository: context.read<CategoryRepository>(), notificationService: notificationService),
          ),
          BlocProvider<TaskDetailsBloc>(create: (context) => TaskDetailsBloc(taskRepository: context.read<TaskRepository>())),
          BlocProvider<CategoryBloc>(create: (context) => CategoryBloc(categoryRepository: context.read<CategoryRepository>())),
          BlocProvider<MoodBloc>(create: (context) => MoodBloc(context.read<MoodRepository>())),
          BlocProvider<UserBloc>(create: (context) => UserBloc(context.read<UserRepository>())),
        ],
        child: MultiProvider(
          providers: [
            ChangeNotifierProvider.value(value: settingsService),
            ChangeNotifierProvider.value(value: colorCustomizationService),
            ChangeNotifierProvider.value(value: AmbientService()),
            ChangeNotifierProvider.value(value: EmergencyService()),
            ChangeNotifierProvider.value(value: taskSoundService),
            ChangeNotifierProvider.value(value: updateService),
          ],
          child: Consumer2<settings.SettingsService, ColorCustomizationService>(
            builder: (context, settingsService, colorCustomizationService, child) {
              // Initialize localization service
              LocalizationService.initialize(context);

              return MaterialApp(
                debugShowCheckedModeBanner: false,
                navigatorKey: NavigationService.navigatorKey,
                title: 'Tazbeet',
                routes: {'/mood_input': (context) => BlocProvider.value(value: context.read<MoodBloc>(), child: const MoodInputScreen())},
                theme: AppThemes.getLightThemeWithCustomization(colorCustomizationService),
                darkTheme: AppThemes.getDarkThemeWithCustomization(colorCustomizationService),
                themeMode: _getThemeMode(settingsService.settings.themeMode),
                builder: (context, child) {
                  final mediaQuery = MediaQuery.of(context);
                  return MediaQuery(
                    data: mediaQuery.copyWith(textScaler: TextScaler.linear(settingsService.settings.enableLargeText ? 1.3 : 1.0)),
                    child: child!,
                  );
                },
                locale: _getLocale(settingsService.settings.language),
                localizationsDelegates: const [AppLocalizations.delegate, GlobalMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, GlobalCupertinoLocalizations.delegate],
                supportedLocales: AppLocalizations.supportedLocales,
                home: BlocBuilder<AuthBloc, AuthState>(
                  builder: (context, authState) {
                    return const SplashScreen();
                  },
                ),
              );
            },
          ),
        ),
      ),
    );
  }
}
 /*

import 'package:flutter/material.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:timezone/data/latest.dart' as tz;
import 'package:timezone/timezone.dart' as tz;

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  tz.initializeTimeZones(); // üìù ÿ∂ÿ±Ÿàÿ±Ÿä ŸÑÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖŸÜÿ∑ŸÇÿ© ÿßŸÑÿ≤ŸÖŸÜŸäÿ© ÿßŸÑŸÖÿ≠ŸÑŸäÿ©
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(title: 'Reminder App', home: ReminderPage());
  }
}

class ReminderPage extends StatefulWidget {
  @override
  _ReminderPageState createState() => _ReminderPageState();
}

class _ReminderPageState extends State<ReminderPage> {
  late FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin;
  String _selectedRepeat = 'none'; // üìù ŸÑŸÑÿßÿ≠ÿ™ŸÅÿßÿ∏ ÿ®ÿÆŸäÿßÿ± ÿßŸÑÿ™ŸÉÿ±ÿßÿ±

  @override
  void initState() {
    super.initState();
    initializeNotifications();
  }

  void initializeNotifications() async {
    flutterLocalNotificationsPlugin = FlutterLocalNotificationsPlugin();

    // üìù ÿ•ÿπÿØÿßÿØ Android
    const AndroidInitializationSettings androidSettings = AndroidInitializationSettings('@mipmap/ic_launcher');

    // üìù ÿ•ÿπÿØÿßÿØÿßÿ™ ÿ™ŸáŸäÿ¶ÿ© ÿπÿßŸÖÿ©
    const InitializationSettings initSettings = InitializationSettings(android: androidSettings);

    // üìù ÿ™ŸáŸäÿ¶ÿ© ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™
    await flutterLocalNotificationsPlugin.initialize(
      initSettings,
      onDidReceiveNotificationResponse: (NotificationResponse response) {
        // üìù ÿ±ÿØ ÿßŸÑŸÅÿπŸÑ ÿπŸÜÿØ ÿßŸÑÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ ÿßŸÑÿ•ÿ¥ÿπÿßÿ± ÿ£Ÿà ÿ≤ÿ± ÿßŸÑÿ™ŸÅÿßÿπŸÑ
        if (response.payload != null) {
          print('ÿ™ŸÖ ÿßŸÑÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ ÿßŸÑÿ•ÿ¥ÿπÿßÿ± ŸÖÿπ ÿßŸÑÿ≠ŸÖŸàŸÑÿ©: ${response.payload}');
        }
      },
    );
  }

  /// üß† ÿØÿßŸÑÿ© ŸÑÿ¨ÿØŸàŸÑÿ© ÿ™ÿ∞ŸÉŸäÿ± ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿßŸÑŸàŸÇÿ™ ŸàÿÆŸäÿßÿ± ÿßŸÑÿ™ŸÉÿ±ÿßÿ±
  Future<void> scheduleReminder(DateTime scheduledTime) async {
    // üìù ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑŸàŸÇÿ™ ÿ•ŸÑŸâ ÿßŸÑŸÖŸÜÿ∑ŸÇÿ© ÿßŸÑÿ≤ŸÖŸÜŸäÿ©
    final tz.TZDateTime scheduledDate = tz.TZDateTime.from(scheduledTime, tz.local);

    // üìù ÿ•ÿπÿØÿßÿØ ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿ•ÿ¥ÿπÿßÿ± (ŸÖÿπ ÿ≤ÿ± ÿ™ŸÅÿßÿπŸÑŸä)
    const AndroidNotificationDetails androidDetails = AndroidNotificationDetails(
      'reminder_channel', // ŸÖÿπÿ±ŸÅ ÿßŸÑŸÇŸÜÿßÿ©
      'Reminders', // ÿßÿ≥ŸÖ ÿßŸÑŸÇŸÜÿßÿ©
      channelDescription: 'Channel for Reminder notifications',
      importance: Importance.max,
      priority: Priority.high,
      playSound: true,
      actions: <AndroidNotificationAction>[
        AndroidNotificationAction(
          'done', // üìù ŸÖÿπÿ±ŸÅ ÿßŸÑÿ≤ÿ±
          'ÿ™ŸÖ', // üìù ÿßÿ≥ŸÖ ÿßŸÑÿ≤ÿ±
        ),
      ],
    );

    // üìù ÿ∂ÿ®ÿ∑ ÿÆÿµÿßÿ¶ÿµ ÿßŸÑÿ™ÿ∞ŸÉŸäÿ± ÿ≠ÿ≥ÿ® ÿßŸÑÿ™ŸÉÿ±ÿßÿ±
    DateTimeComponents? repeatComponent;
    if (_selectedRepeat == 'daily') {
      repeatComponent = DateTimeComponents.time; // ÿ™ŸÉÿ±ÿßÿ± ŸäŸàŸÖŸä
    } else if (_selectedRepeat == 'weekly') {
      repeatComponent = DateTimeComponents.dayOfWeekAndTime; // ÿ™ŸÉÿ±ÿßÿ± ÿ£ÿ≥ÿ®ŸàÿπŸä
    }

    await flutterLocalNotificationsPlugin.zonedSchedule(
      0, // üìù ŸÖÿπÿ±ŸÅ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±
      'üîî ÿ™ÿ∞ŸÉŸäÿ±',
      'üìå ŸÑÿß ÿ™ŸÜÿ≥Ÿé ŸÖŸáŸÖÿ™ŸÉ ÿßŸÑŸÖÿ¨ÿØŸàŸÑÿ©!',
      scheduledDate,
      NotificationDetails(android: androidDetails),

      payload: 'reminder_payload',
      androidScheduleMode: AndroidScheduleMode.alarmClock, // üìù ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿ•ÿ∂ÿßŸÅŸäÿ©
    );
  }

  /// üß† ÿØÿßŸÑÿ© ŸÑÿ•ŸÑÿ∫ÿßÿ° ÿ¨ŸÖŸäÿπ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™
  Future<void> cancelAllReminders() async {
    await flutterLocalNotificationsPlugin.cancelAll();
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('‚úÖ ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿ¨ŸÖŸäÿπ ÿßŸÑÿ™ÿ∞ŸÉŸäÿ±ÿßÿ™')));
  }

  /// üß† ÿØÿßŸÑÿ© ŸÑÿßÿÆÿ™Ÿäÿßÿ± ŸàŸÇÿ™ ÿßŸÑÿ™ÿ∞ŸÉŸäÿ± ÿ´ŸÖ ÿ¨ÿØŸàŸÑÿ™Ÿá
  void _pickTimeAndScheduleReminder() async {
    final TimeOfDay? picked = await showTimePicker(context: context, initialTime: TimeOfDay.now());

    if (picked != null) {
      final now = DateTime.now();

      final scheduledDate = DateTime(now.year, now.month, now.day, picked.hour, picked.minute);

      await scheduleReminder(scheduledDate);

      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('üïë ÿ™ŸÖ ÿ¨ÿØŸàŸÑÿ© ÿßŸÑÿ™ÿ∞ŸÉŸäÿ±')));
    }
  }

  /// üß† Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('üìÖ ÿ¨ÿØŸàŸÑ ÿßŸÑÿ™ÿ∞ŸÉŸäÿ±')),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          children: [
            // üìù ÿ≤ÿ± ŸÑÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑŸàŸÇÿ™
            ElevatedButton(onPressed: _pickTimeAndScheduleReminder, child: Text('ÿßÿÆÿ™ÿ± ŸàŸÇÿ™ ÿßŸÑÿ™ÿ∞ŸÉŸäÿ±')),
            SizedBox(height: 20),
            // üìù ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑÿ™ŸÉÿ±ÿßÿ±
            DropdownButton<String>(
              value: _selectedRepeat,
              items: const [
                DropdownMenuItem(value: 'none', child: Text('ÿ®ÿØŸàŸÜ ÿ™ŸÉÿ±ÿßÿ±')),
                DropdownMenuItem(value: 'daily', child: Text('ÿ™ŸÉÿ±ÿßÿ± ŸäŸàŸÖŸä')),
                DropdownMenuItem(value: 'weekly', child: Text('ÿ™ŸÉÿ±ÿßÿ± ÿ£ÿ≥ÿ®ŸàÿπŸä')),
              ],
              onChanged: (value) {
                setState(() {
                  _selectedRepeat = value!;
                });
              },
            ),
            SizedBox(height: 20),
            // üìù ÿ≤ÿ± ŸÑÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿ™ÿ∞ŸÉŸäÿ±ÿßÿ™
            ElevatedButton(
              onPressed: cancelAllReminders,
              style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
              child: Text('ÿ•ŸÑÿ∫ÿßÿ° ŸÉŸÑ ÿßŸÑÿ™ÿ∞ŸÉŸäÿ±ÿßÿ™'),
            ),
          ],
        ),
      ),
    );
  }
}
*/